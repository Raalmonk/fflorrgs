<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M-Spec - Timeline</title>

    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 2. Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 3. Environment Setup -->
    <script>
        window.process = { env: { NODE_ENV: 'production' } };
    </script>

    <!-- 4. API Client (Placeholder/Mock) -->
    <script src="api.js"></script>

    <style>
        /* Scrollbar Styling */
        .custom-scrollbar::-webkit-scrollbar {
            width: 12px;
            height: 12px;
            background: #121212;
        }
        .custom-scrollbar::-webkit-scrollbar-corner {
            background: #121212;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #333;
            border: 3px solid #121212;
            border-radius: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #00FF96;
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        body { margin: 0; overflow: hidden; background-color: #121212; user-select: none; }

        /* Custom Drag Cursor */
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- 4. React App -->
    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect, useMemo, useCallback } from 'https://esm.sh/react@18.2.0?dev';
        import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client?dev';
        import { ZoomIn, ZoomOut, Search, Menu, Skull, Clock, Hourglass, Shield, ShieldAlert, Zap, Swords, MoreHorizontal, Layers, Minimize2, Maximize2, ChevronDown, ExternalLink, Flag } from 'https://esm.sh/lucide-react@0.263.1?dev';

        // --- Configuration ---
        const THEME_COLOR = '#00FF96';
        const JOB_COLOR_RDM = '#E87B7B';
        const FIGHT_DURATION = 1200; // Increased to 10 minutes (600s) to fix the "7 minute" overflow issue
        const API_BASE = 'http://127.0.0.1:5000';
        const LEFT_PANEL_WIDTH = 260; 

        // Palette for Duration Bars (Sequential assignment)
        const DURATION_PALETTE = [
            '#F87171', '#FB923C', '#FACC15', '#A3E635', 
            '#34D399', '#22D3EE', '#60A5FA', '#818CF8', 
            '#A78BFA', '#E879F9', '#FB7185', '#F472B6'
        ];

        // --- Mock Data Layer ---
        const fetchSpellCategories = async () => ({
            // defaultActive: controls if spells in this category are shown by default
            MAJOR: { label: 'CD', color: '#E87B7B', iconType: 'swords', defaultActive: true },
            SINGLE_MIT: { label: 'Single Mit', color: '#4facfe', iconType: 'shield', defaultActive: false },
            RAID_MIT: { label: 'Group Mit', color: '#8657FF', iconType: 'shieldAlert', defaultActive: true },
            UTILITY: { label: 'Utility', color: '#E6B33D', iconType: 'zap', defaultActive: false },
        });

        // 1. fetchSpellData (API)
        const fetchSpellData = async (specSlug = 'redmage-redmage') => {
            const res = await fetch(`${API_BASE}/api/specs/${specSlug}/spells`);
            const data = await res.json();

            const resolveCategory = (tags, spellName) => {
                const lowerName = spellName ? spellName.toLowerCase() : '';
                if (lowerName.includes('sprint') || lowerName.includes('gemdraught') || lowerName.includes('potion')) {
                    return 'UTILITY';
                }
                if (!tags || tags.length === 0) return 'MAJOR';
                const tagSet = new Set(tags.map(t => String(t).toLowerCase()));
                if (tagSet.has('raid_mit') || tagSet.has('raid_cd')) return 'RAID_MIT';
                if (tagSet.has('single_mit') || tagSet.has('tank_mit') || tagSet.has('defensive')) return 'SINGLE_MIT';
                if (tagSet.has('utility') || tagSet.has('potion')) return 'UTILITY';
                return 'MAJOR';
            };

            const spellMap = {};
            data.forEach((spell, index) => {
                spellMap[spell.spell_id] = {
                    id: spell.spell_id,
                    name: spell.name,
                    image: spell.icon.startsWith('http') ? spell.icon : `${API_BASE}/lorrgs_assets/images/spells/` + spell.icon,
                    cd: spell.cooldown || 0,
                    duration: spell.duration || 0,
                    color: spell.color || '#ffcc00',
                    desc: spell.desc || '',
                    category: resolveCategory(spell.tags, spell.name),
                    show: spell.show,
                    load_order: spell.load_order !== undefined ? spell.load_order : index
                };
            });
            return spellMap;
        };

        // Mock Data for Specs - Moved to Global Scope
        const SPECS = [
            { label: 'Tanks', items: [
                {id:'paladin-paladin', icon:'paladin.png', n:'Paladin'},
                {id:'warrior-warrior', icon:'warrior.png', n:'Warrior'},
                {id:'darkknight-darkknight', icon:'Dark_Knight.png', n:'Dark Knight'},
                {id:'gunbreaker-gunbreaker', icon:'Gunbreaker.png', n:'Gunbreaker'}
            ]},
            { label: 'Healers', items: [
                {id:'whitemage-whitemage', icon:'White_Mage.png', n:'White Mage'},
                {id:'scholar-scholar', icon:'Scholar.png', n:'Scholar'},
                {id:'astrologian-astrologian', icon:'Astrologian.png', n:'Astrologian'},
                {id:'sage-sage', icon:'Sage.png', n:'Sage'}
            ]},
            { label: 'Melee', items: [
                {id:'monk-monk', icon:'monk.png', n:'Monk'},
                {id:'dragoon-dragoon', icon:'Dragoon.png', n:'Dragoon'},
                {id:'ninja-ninja', icon:'Ninja.png', n:'Ninja'},
                {id:'samurai-samurai', icon:'Samurai.png', n:'Samurai'},
                {id:'reaper-reaper', icon:'Reaper.png', n:'Reaper'},
                {id:'viper-viper', icon:'Viper.png', n:'Viper'}
            ]},
            { label: 'Physical Ranged', items: [
                {id:'bard-bard', icon:'Bard.png', n:'Bard'},
                {id:'machinist-machinist', icon:'Machinist.png', n:'Machinist'},
                {id:'dancer-dancer', icon:'Dancer.png', n:'Dancer'}
            ]},
            { label: 'Magical Ranged', items: [
                {id:'blackmage-blackmage', icon:'Black_Mage.png', n:'Black Mage'},
                {id:'summoner-summoner', icon:'Summoner.png', n:'Summoner'},
                {id:'redmage-redmage', icon:'Red_Mage.png', n:'Red Mage'},
                {id:'pictomancer-pictomancer', icon:'Pictomancer.png', n:'Pictomancer'}
            ]},
        ];

        const getIconForSpec = (specSlug) => {
             const item = SPECS.flatMap(g => g.items).find(i => i.id === specSlug);
             return item ? item.icon : null;
        };

        const getRole = (specSlug) => {
            if (specSlug.includes('paladin') || specSlug.includes('warrior') || specSlug.includes('darkknight') || specSlug.includes('gunbreaker')) return 'tank';
            if (specSlug.includes('whitemage') || specSlug.includes('scholar') || specSlug.includes('astrologian') || specSlug.includes('sage')) return 'healer';
            return 'dps';
        };

        const getDetailedRole = (specSlug) => {
            const group = SPECS.find(g => g.items.some(i => i.id === specSlug));
            if (!group) return 'dps';
            if (group.label === 'Tanks') return 'tank';
            if (group.label === 'Healers') return 'healer';
            if (group.label === 'Melee') return 'melee';
            if (group.label === 'Physical Ranged') return 'phys_ranged';
            if (group.label === 'Magical Ranged') return 'magic_ranged';
            return 'dps';
        };

        // NEW: URL Helper
        const getFFLogsUrl = (reportId, fightId, region) => {
            // Default to global if undefined
            const baseUrl = (region === "CN") ? "https://cn.fflogs.com" : "https://www.fflogs.com";
            return `${baseUrl}/reports/${reportId}#fight=${fightId}`;
        };

        // 2. fetchRankings (API with Region & Partner Logic)
        const fetchRankings = async (specSlug, bossSlug, spellMap, currentRankData = []) => {
            console.log('[M-Spec] Starting fetch for:', specSlug, bossSlug);

            try {
                const res = await fetch(`./data/spec_ranking_${specSlug}_${bossSlug}.json?t=${Date.now()}`);
                const data = await res.json();
                
                const allPlayers = [];
                if (data.reports) {
                    data.reports.forEach(report => {
                        if (report.fights) {
                            report.fights.forEach(fight => {
                                if (fight.players) {
                                    fight.players.forEach(player => {
                                        player.fightDuration = fight.duration;
                                        player.fightId = fight.fight_id;
                                        player.reportId = report.report_id;
                                        player.region = report.region;
                                        player.composition = fight.composition || []; // New: composition
                                        allPlayers.push(player);
                                    });
                                }
                            });
                        }
                    });
                }

                allPlayers.sort((a, b) => b.total - a.total);
                // Filter out non-ranked players (partners) from the ranking list
                // Ranked players usually have high DPS/HPS (total > 0). Partners have 0.
                // Or simply: SpecRanking only loads full casts for players in `self.players` which were initially just the ranked ones.
                // But we added partners to `fight.players`.
                // We should filter to only show the "main" spec we are looking at.
                // The `specSlug` argument tells us which spec we are ranking.
                const rankedPlayers = allPlayers.filter(p => p.spec_slug === specSlug && p.total > 0).slice(0, 70);

                const userRole = getRole(specSlug);

                const rankData = rankedPlayers.map((player, index) => {
                     const id = `player-${player.source_id || index}`;
                     
                     const region = player.region || '??';

                     // Smart Partner Logic
                     let partnerIcon = null;
                     const composition = player.composition || [];
                     const myDetailedRole = getDetailedRole(player.spec_slug);

                     // Count players with same detailed role
                     const sameRoleSpecs = composition.filter(s => getDetailedRole(s) === myDetailedRole);

                     if (sameRoleSpecs.length === 2) {
                         // Exactly one partner
                         // Find the other spec.
                         // Logic: make a copy, remove current player's spec once, take the remaining one.
                         const partners = [...sameRoleSpecs];
                         const myIndex = partners.indexOf(player.spec_slug);
                         if (myIndex > -1) {
                             partners.splice(myIndex, 1);
                         }
                         const partnerSpec = partners[0];
                         if (partnerSpec) {
                            const iconName = getIconForSpec(partnerSpec);
                            if (iconName) {
                                partnerIcon = `${API_BASE}/lorrgs_assets/images/classes/${iconName}`;
                            }
                         }
                     }

                     const finalPartner = partnerIcon;

                     const existing = currentRankData.find(p => p.id === id);
                     const durationSeconds = player.fightDuration / 1000;
                     const m = Math.floor(durationSeconds / 60);
                     const s = Math.floor(durationSeconds % 60).toString().padStart(2, '0');

                     if (existing) {
                         // Simple cache check
                         if (Math.abs((existing.dps || 0) - player.total) < 0.1) {
                            // Ensure new fields are passed even if cached (though usually cache is object ref)
                            return { ...existing, rank: index + 1, composition: composition, partner: finalPartner, reportId: player.reportId, fightId: player.fightId, killTimeSeconds: durationSeconds };
                         }
                     }

                     return {
                        rank: index + 1,
                        id: id,
                        name: player.name,
                        region: region, 
                        reportId: player.reportId, // NEW
                        fightId: player.fightId,   // NEW
                        partner: finalPartner, // New Field
                        composition: composition,
                        dps: player.total,
                        killTime: `${m}:${s}`,
                        killTimeSeconds: durationSeconds, // Added for timeline cutoff
                        casts: (player.casts || []).map(c => ({
                            spellId: c.spell_id,
                            timestamp: c.ts ? c.ts / 1000 : (c.timestamp || 0),
                            duration: c.duration || (spellMap[c.spell_id] ? spellMap[c.spell_id].duration : 0)
                        })),
                        deaths: []
                    };
                });
                return rankData;
            } catch (error) {
                console.error('[M-Spec] Error fetching rankings:', error);
                return [];
            }
        };

        const parseTime = (timeStr) => {
            if (!timeStr) return 0;
            const parts = timeStr.split(':');
            if (parts.length === 2) {
                return parseInt(parts[0]) * 60 + parseInt(parts[1]);
            }
            return parseInt(timeStr);
        };

        const fetchBossMechanics = async (bossSlug) => {
            if (!bossSlug) return [];
            try {
                const res = await fetch(`${API_BASE}/api/bosses/${bossSlug}/spells`);
                const data = await res.json();
                return Object.values(data)
                    .filter(spell => spell.time)
                    .map(spell => {
                        let color = '#4da6ff';
                        const tags = spell.tags || [];
                        const tagSet = new Set(tags.map(t => String(t).toLowerCase()));
                        if (tagSet.has('raid_mit') || tagSet.has('raid_cd')) color = '#8657FF';
                        else if (tagSet.has('tank_mit') || tagSet.has('tank')) color = '#ff944d';
                        else if (tagSet.has('utility')) color = '#E6B33D';
                        return {
                            time: parseTime(spell.time),
                            duration: spell.duration || 0, // Ensure default 0 if null
                            name: spell.name,
                            icon: spell.icon ? (spell.icon.startsWith('http') ? spell.icon : `${API_BASE}/lorrgs_assets/images/spells/` + spell.icon) : null,
                            type: 'mech',
                            color: color
                        };
                    })
                    .sort((a, b) => a.time - b.time);
            } catch (e) {
                console.error("Failed to fetch boss mechanics", e);
                return [];
            }
        };

        const calculateCastTracks = (casts) => {
            if (!casts || casts.length === 0) return { tracks: [], maxTracks: 1 };
            // Sort by timestamp for proper overlap rendering
            const sortedCasts = [...casts].sort((a, b) => a.timestamp - b.timestamp);

            const tracks = [];
            const results = [];

            sortedCasts.forEach(cast => {
                // Heuristic for visual overlap prevention
                const castEnd = cast.timestamp + Math.max(cast.duration || 0, 5) + 2; 
                let placed = false;
                for (let i = 0; i < tracks.length; i++) {
                    if (tracks[i] <= cast.timestamp) {
                        tracks[i] = castEnd;
                        results.push({ ...cast, trackIndex: i });
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    results.push({ ...cast, trackIndex: tracks.length });
                    tracks.push(castEnd);
                }
            });

            return { processedCasts: results, maxTracks: Math.max(1, tracks.length) };
        };

        // --- Components ---
        const CategoryIcon = ({ type }) => {
            switch(type) {
                case 'swords': return <Swords size={14} />;
                case 'shield': return <Shield size={14} />;
                case 'shieldAlert': return <ShieldAlert size={14} />;
                case 'zap': return <Zap size={14} />;
                default: return <MoreHorizontal size={14} />;
            }
        };

        const RenderIcon = ({ spell, className }) => {
            // Check spell.image (player spells) or spell.icon (boss mechanics)
            const imgUrl = spell.image || spell.icon;
            if (imgUrl) return <img src={imgUrl} alt={spell.name} className={`w-full h-full object-cover ${className}`} />;
            return <div className={`flex items-center justify-center w-full h-full text-sm select-none bg-gray-700 ${className}`}>{spell.char || (spell.name ? spell.name[0] : '?')}</div>;
        };

        // NEW: Player Name/DPS Toggle Cell Component with Jump Link
        const PlayerNameCell = ({ name, dps, reportId, fightId, region }) => {
            const [viewMode, setViewMode] = useState('dps'); // 'dps' or 'name'
            const timeoutRef = useRef(null);

            const handleMouseEnter = () => {
                if (timeoutRef.current) clearTimeout(timeoutRef.current);
                setViewMode('name');
            };

            const handleMouseLeave = () => {
                timeoutRef.current = setTimeout(() => {
                    setViewMode('dps');
                }, 5000); // 5 seconds delay
            };

            const url = getFFLogsUrl(reportId, fightId, region);

            return (
                <a 
                    href={url}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex-1 relative h-full flex items-center pr-2 cursor-pointer group/link hover:bg-white/5 transition-colors rounded"
                    onMouseEnter={handleMouseEnter}
                    onMouseLeave={handleMouseLeave}
                    title="Open in FF Logs"
                >
                    {/* DPS Layer (Default) */}
                    <span 
                        className={`absolute inset-0 flex items-center font-bold text-[#00FF96] drop-shadow-[0_1px_2px_rgba(0,0,0,0.8)] transition-opacity duration-500 ${viewMode === 'dps' ? 'opacity-100' : 'opacity-0'}`}
                        style={{ fontSize: '19px', lineHeight: 1 }}
                    >
                        {Math.round(dps).toLocaleString()}
                    </span>
                    
                    {/* Name Layer (On Hover) */}
                    <span 
                        className={`absolute inset-0 flex items-center font-bold text-white truncate transition-opacity duration-500 underline decoration-gray-500 group-hover/link:decoration-[#00FF96] drop-shadow-[0_1px_2px_rgba(0,0,0,0.8)] ${viewMode === 'name' ? 'opacity-100' : 'opacity-0'}`}
                        style={{ fontSize: '15px' }}
                    >
                        {name}
                        <ExternalLink size={12} className="ml-1 opacity-50 group-hover/link:opacity-100" />
                    </span>
                </a>
            );
        };

        // Composition Filter Component
        const CompositionFilter = ({ activeFilterSpecs, onApply }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [tempSelected, setTempSelected] = useState(new Set(activeFilterSpecs));
            const ref = useRef(null);

            useEffect(() => {
                if (isOpen) setTempSelected(new Set(activeFilterSpecs));
            }, [isOpen, activeFilterSpecs]);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (ref.current && !ref.current.contains(event.target)) setIsOpen(false);
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            const toggleSpec = (specId) => {
                const newSet = new Set(tempSelected);
                if (newSet.has(specId)) newSet.delete(specId); else newSet.add(specId);
                setTempSelected(newSet);
            };

            const handleApply = () => {
                onApply(tempSelected);
                setIsOpen(false);
            };

            return (
                <div className="relative" ref={ref}>
                    <button
                        onClick={() => setIsOpen(!isOpen)}
                        className={`flex items-center gap-2 px-3 py-1.5 border rounded-md text-sm transition-colors ${activeFilterSpecs.size > 0 ? 'bg-[#00FF96]/20 border-[#00FF96] text-white' : 'bg-black/30 border-gray-700 text-gray-400 hover:border-[#00FF96]'}`}
                    >
                        <span>With... {activeFilterSpecs.size > 0 && `(${activeFilterSpecs.size})`}</span>
                        <ChevronDown size={14} />
                    </button>

                    {isOpen && (
                        <div className="absolute top-full left-0 mt-2 w-80 bg-[#1a1a1a] border border-gray-700 rounded-lg shadow-xl z-[70] p-4 flex flex-col gap-4 max-h-[500px] overflow-y-auto custom-scrollbar">
                            <div className="flex flex-col gap-4">
                                {SPECS.map((group, idx) => (
                                    <div key={idx} className="flex flex-col gap-2">
                                        <span className="text-[10px] uppercase text-gray-500 font-bold">{group.label}</span>
                                        <div className="flex flex-wrap gap-2">
                                            {group.items.map(item => {
                                                const isSelected = tempSelected.has(item.id);
                                                return (
                                                    <button
                                                        key={item.id}
                                                        onClick={() => toggleSpec(item.id)}
                                                        className={`w-9 h-9 flex items-center justify-center rounded border transition-all relative ${isSelected ? 'bg-[#333] border-[#00FF96]' : 'bg-[#252525] border-transparent hover:bg-[#333]'}`}
                                                        title={item.n}
                                                    >
                                                        <img src={`${API_BASE}/lorrgs_assets/images/classes/${item.icon}`} alt={item.n} className="w-full h-full object-cover rounded-sm" />
                                                        {isSelected && <div className="absolute inset-0 border-2 border-[#00FF96] rounded pointer-events-none"></div>}
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                            <div className="flex items-center justify-between pt-2 border-t border-gray-700">
                                <button onClick={() => setIsOpen(false)} className="text-xs text-gray-400 hover:text-white px-2 py-1">Cancel</button>
                                <button onClick={handleApply} className="text-xs bg-[#00FF96] text-black font-bold px-3 py-1.5 rounded hover:bg-[#00cc78]">Confirm</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Custom Spec Selector
        const SpecSelector = ({ selectedSpec, onChange }) => {
            const [isOpen, setIsOpen] = useState(false);
            const ref = useRef(null);

            // Uses Global SPECS variable
            
            const currentSpecItem = SPECS.flatMap(g => g.items).find(i => i.id === selectedSpec);
            const currentIcon = currentSpecItem?.icon || 'Red_Mage.png';
            const currentName = currentSpecItem?.n || 'Red Mage';

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (ref.current && !ref.current.contains(event.target)) setIsOpen(false);
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            return (
                <div className="relative" ref={ref}>
                    <button 
                        onClick={() => setIsOpen(!isOpen)} 
                        className="flex items-center gap-2 px-3 py-1.5 bg-black/30 border border-gray-700 rounded-md text-sm hover:border-[#00FF96] transition-colors"
                    >
                        <img src={`${API_BASE}/lorrgs_assets/images/classes/${currentIcon}`} alt={currentName} className="w-5 h-5 object-contain" />
                        <span className="font-medium text-white">{currentName}</span>
                        <ChevronDown size={14} className="text-gray-400" />
                    </button>

                    {isOpen && (
                        <div className="absolute top-full left-0 mt-2 w-64 bg-[#1a1a1a] border border-gray-700 rounded-lg shadow-xl z-[70] p-2 flex flex-col gap-2 max-h-[400px] overflow-y-auto custom-scrollbar">
                            {SPECS.map((group, idx) => (
                                <div key={idx} className="flex flex-col gap-1">
                                    <span className="text-[10px] uppercase text-gray-500 font-bold px-1">{group.label}</span>
                                    <div className="flex flex-wrap gap-1">
                                        {group.items.map(item => (
                                            <button 
                                                key={item.id}
                                                onClick={() => { onChange(item.id); setIsOpen(false); }}
                                                className={`w-8 h-8 flex items-center justify-center rounded border transition-all overflow-hidden ${selectedSpec === item.id ? 'bg-[#333] border-[#00FF96]' : 'bg-[#252525] border-transparent hover:bg-[#333] hover:border-[#00FF96]'}`}
                                                title={item.n}
                                            >
                                                <img src={`${API_BASE}/lorrgs_assets/images/classes/${item.icon}`} alt={item.n} className="w-full h-full object-cover" />
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        // --- Main App ---
        const App = () => {
            // 1. ÂÆö‰πâ‰∏Ä‰∏™ËæÖÂä©ÂáΩÊï∞Êù•ËØªÂèñ URL ÂèÇÊï∞
            const getQueryParam = (param, defaultValue) => {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get(param) || defaultValue;
            };

            const [zoom, setZoom] = useState(15);
            const [isCollapsed, setIsCollapsed] = useState(true); // Default to Collapsed
            const [viewMode, setViewMode] = useState('damage');
            
            // 2. ‰øÆÊîπËøôÈáåÔºö‰ΩøÁî® getQueryParam Êù•ËÆæÁΩÆÂàùÂßãÂÄº
            const [selectedBoss, setSelectedBoss] = useState(getQueryParam('boss', 'vamp-fatale'));
            const [selectedSpec, setSelectedSpec] = useState(getQueryParam('spec', 'redmage-redmage'));
            const [activeFilterSpecs, setActiveFilterSpecs] = useState(new Set()); // New State
            
            const [spellCategories, setSpellCategories] = useState({});
            const [spells, setSpells] = useState({});
            const [bossMechanics, setBossMechanics] = useState([]);
            const [rankData, setRankData] = useState([]);
            const [loading, setLoading] = useState(true);

            const [showDuration, setShowDuration] = useState(true);
            const [showCooldown, setShowCooldown] = useState(true);
            const [showDeaths, setShowDeaths] = useState(true);
            const [showPhases, setShowPhases] = useState(true);
            const [showBossRow, setShowBossRow] = useState(true);

            const [selectedSpells, setSelectedSpells] = useState(new Set());
            const scrollContainerRef = useRef(null);

            // consistent spell coloring
            const spellColorMap = useMemo(() => {
                const map = {};
                let colorIdx = 0;
                // Sort spells by ID to ensure consistency
                const sortedSpellIds = Object.keys(spells).sort();

                sortedSpellIds.forEach(spellId => {
                    map[spellId] = DURATION_PALETTE[colorIdx % DURATION_PALETTE.length];
                    colorIdx++;
                });
                return map;
            }, [spells]);

            // Drag State (Refactored to Refs for robustness)
            const [isDraggingState, setIsDraggingState] = useState(false); // Only for UI cursor update
            const dragInfo = useRef({
                isDown: false,
                startX: 0,
                scrollLeft: 0
            });

            useEffect(() => {
                const load = async () => {
                    setLoading(true);
                    const cats = await fetchSpellCategories();
                    const sps = await fetchSpellData(selectedSpec);
                    const mechs = await fetchBossMechanics(selectedBoss);
                    const ranks = await fetchRankings(selectedSpec, selectedBoss, sps, rankData);

                    setSpellCategories(cats); setSpells(sps); setBossMechanics(mechs); setRankData(ranks);
                    
                    // Filter default active spells
                    const defaultSelectedIds = Object.values(sps)
                        .filter(s => {
                            if (s.show !== null && s.show !== undefined) {
                                return s.show;
                            }
                            const cat = cats[s.category];
                            return cat ? cat.defaultActive : true;
                        })
                        .map(s => s.id);
                    setSelectedSpells(new Set(defaultSelectedIds));

                    setLoading(false);
                };
                load();
            }, [selectedBoss, selectedSpec]);

            const toggleSpell = (spellId) => {
                const newSet = new Set(selectedSpells);
                if (newSet.has(spellId)) newSet.delete(spellId); else newSet.add(spellId);
                setSelectedSpells(newSet);
            };

            const toggleCategory = (catKey) => {
                const spellsInCat = Object.values(spells).filter(s => s.category === catKey);
                // Determine logic: if ANY are unselected, select ALL. If ALL are selected, deselect ALL.
                const allSelected = spellsInCat.every(s => selectedSpells.has(s.id));
                const newSet = new Set(selectedSpells);
                spellsInCat.forEach(s => {
                    if (allSelected) newSet.delete(s.id); else newSet.add(s.id);
                });
                setSelectedSpells(newSet);
            };

            const handleZoomIn = () => setZoom(prev => Math.min(prev + 5, 100));
            const handleZoomOut = () => setZoom(prev => Math.max(prev - 5, 5));
            const formatTime = (s) => `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, '0')}`;

            // --- Robust Drag Implementation ---
            const onMouseDown = useCallback((e) => {
                dragInfo.current = {
                    isDown: true,
                    startX: e.pageX,
                    scrollLeft: scrollContainerRef.current.scrollLeft
                };
                setIsDraggingState(true);
                
                // Add listeners to window to catch movements outside the container
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
                
                // Prevent text selection
                e.preventDefault(); 
            }, []);

            const onMouseMove = useCallback((e) => {
                if (!dragInfo.current.isDown) return;
                e.preventDefault();
                
                const x = e.pageX;
                const walk = (x - dragInfo.current.startX) * 1.5; // Scroll speed multiplier
                if (scrollContainerRef.current) {
                    scrollContainerRef.current.scrollLeft = dragInfo.current.scrollLeft - walk;
                }
            }, []);

            const onMouseUp = useCallback(() => {
                dragInfo.current.isDown = false;
                setIsDraggingState(false);
                
                // Clean up window listeners
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
            }, [onMouseMove]);

            // Cleanup on unmount
            useEffect(() => {
                return () => {
                    window.removeEventListener('mousemove', onMouseMove);
                    window.removeEventListener('mouseup', onMouseUp);
                };
            }, [onMouseMove, onMouseUp]);


            if (loading) return <div className="h-screen bg-[#121212] flex items-center justify-center text-[#00FF96]">Loading...</div>;

            return (
                <div className="flex flex-col h-screen bg-[#121212] text-gray-300 font-sans overflow-hidden">

                {/* Navbar */}
                <nav className="h-14 bg-[#1a1a1a] border-b border-gray-800 flex items-center justify-between px-4 shrink-0 z-[60]">
                    <div className="flex items-center gap-6">
                        <div className="flex items-center gap-2">
                            <div className="text-xl font-bold tracking-tight text-white flex items-center select-none"><span style={{ color: THEME_COLOR }} className="mr-1">M</span>-Spec</div>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="text-gray-400 text-sm">Boss:</span>
                            <select value={selectedBoss} onChange={(e) => setSelectedBoss(e.target.value)} className="bg-black/30 border border-gray-700 text-white text-sm rounded px-2 py-1.5 focus:outline-none focus:border-[#00FF96] cursor-pointer">
                                <option value="vamp-fatale">M9S: Vamp Fatale</option>
                                <option value="red-hot-and-deep-blue">M10S: Red Hot and Deep Blue</option>
                                <option value="the-tyrant">M11S: The Tyrant</option>
                                <option value="lindwurm">M12S P1: Lindwurm</option>
                            </select>
                            <span className="w-px h-3 bg-gray-600 mx-2"></span>
                            <span className="text-gray-400 text-sm">Spec:</span>
                            <SpecSelector selectedSpec={selectedSpec} onChange={setSelectedSpec} />
                            <span className="w-px h-3 bg-gray-600 mx-2"></span>
                            <CompositionFilter activeFilterSpecs={activeFilterSpecs} onApply={setActiveFilterSpecs} />
                        </div>
                    </div>
                    <div className="flex items-center gap-4">
                    </div>
                </nav>

                {/* Control Bar */}
                <div className="bg-[#181818] border-b border-gray-800 px-4 py-2 shrink-0 flex items-center gap-4 overflow-x-auto no-scrollbar shadow-md z-50">
                    <div className="flex flex-col gap-1 border-r border-gray-700 pr-4 shrink-0">
                        <span className="text-[10px] font-bold text-gray-500 uppercase tracking-wider">Display</span>
                        <div className="flex items-center gap-1">
                            <button title="Duration" onClick={() => setShowDuration(!showDuration)} className={`w-8 h-6 flex items-center justify-center text-sm rounded border transition-colors ${showDuration ? 'bg-[#00FF96]/10 border-[#00FF96] text-[#00FF96]' : 'border-gray-700 text-gray-500 hover:border-gray-500'}`}>‚è≥</button>
                            <button title="Cooldown" onClick={() => setShowCooldown(!showCooldown)} className={`w-8 h-6 flex items-center justify-center text-sm rounded border transition-colors ${showCooldown ? 'bg-[#00FF96]/10 border-[#00FF96] text-[#00FF96]' : 'border-gray-700 text-gray-500 hover:border-gray-500'}`}>üíø</button>
                        </div>
                    </div>
                    <div className="flex flex-col gap-1 border-r border-gray-700 pr-4 shrink-0">
                        <span className="text-[10px] font-bold text-gray-500 uppercase tracking-wider">Boss</span>
                        <div className="flex items-center gap-2">
                            <div className={`w-8 h-8 rounded border-2 overflow-hidden cursor-pointer transition ${showBossRow ? 'border-[#00FF96] opacity-100' : 'border-gray-700 opacity-50 grayscale'}`} onClick={() => setShowBossRow(!showBossRow)} title="Toggle Boss Row">
                                <img src="https://xivapi.com/i/068000/068057.png" alt="Boss" className="w-full h-full object-cover" />
                            </div>
                        </div>
                    </div>
                    <div className="flex items-center gap-6">
                        {Object.entries(spellCategories).map(([catKey, category]) => (
                            <div key={catKey} className="flex flex-col gap-1">
                                <div className="flex items-center gap-1 text-[10px] font-bold text-gray-500 uppercase tracking-wider cursor-pointer hover:text-white" onClick={() => toggleCategory(catKey)}>
                                    <CategoryIcon type={category.iconType} /> {category.label}
                                </div>
                                <div className="flex items-center gap-1.5">
                                    {Object.values(spells).sort((a, b) => a.load_order - b.load_order).filter(spell => spell.category === catKey).map(spell => {
                                        const isSelected = selectedSpells.has(spell.id);
                                        return (
                                            <button
                                                key={spell.id}
                                                onClick={() => toggleSpell(spell.id)}
                                                className={`relative w-8 h-8 rounded border transition-all duration-200 group overflow-hidden ${isSelected ? 'border-transparent opacity-100 shadow-[0_0_10px_rgba(255,255,255,0.1)] grayscale-0' : 'border-gray-800 opacity-30 grayscale hover:opacity-70 hover:border-gray-600'}`}
                                                title={spell.name}
                                            >
                                                <RenderIcon spell={spell} />
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>
                        ))}
                    </div>
                    <div className="flex-1"></div>
                    <div className="flex items-center gap-2 bg-black/20 p-1 rounded-lg border border-gray-800 shrink-0">
                        <button
                            onClick={() => setIsCollapsed(!isCollapsed)}
                            className={`p-1.5 rounded transition ${!isCollapsed ? 'text-[#00FF96] bg-gray-700' : 'text-gray-400 hover:text-white hover:bg-gray-700'}`}
                            title={isCollapsed ? "Expand Rows (Split lines)" : "Collapse Rows"}
                        >
                            <Layers size={16} />
                        </button>
                        <div className="w-px h-4 bg-gray-700 mx-1"></div>
                        <button onClick={handleZoomOut} className="p-1.5 hover:bg-gray-700 rounded text-gray-400 hover:text-[#00FF96] transition"><ZoomOut size={16} /></button>
                        <button onClick={handleZoomIn} className="p-1.5 hover:bg-gray-700 rounded text-gray-400 hover:text-[#00FF96] transition"><ZoomIn size={16} /></button>
                    </div>
                </div>

                {/* Timeline Area */}
                <div className="flex-1 flex overflow-hidden relative">
                    <div 
                        className={`flex-1 overflow-auto bg-[#121212] custom-scrollbar relative ${isDraggingState ? 'cursor-grabbing' : 'cursor-grab'}`} 
                        ref={scrollContainerRef}
                        onMouseDown={onMouseDown}
                    >
                        <div className="min-w-fit pb-10">

                            {/* Sticky Header: Time Ruler */}
                            <div className="sticky top-0 z-50 flex h-8 bg-[#202020] border-b border-gray-800">
                                <div className="sticky left-0 bg-[#202020] border-r border-gray-800 shrink-0 flex items-center px-4 text-xs font-bold text-gray-500 uppercase z-[60] shadow-[4px_0_10px_rgba(0,0,0,0.5)]" style={{ width: `${LEFT_PANEL_WIDTH}px` }}>
                                    <div className="w-8 text-center mr-2 text-[#00FF96]">Rank</div>
                                    {/* MODIFIED: Header Text */}
                                    <div className="flex-1 text-left">RDPS</div>
                                    <div className="w-8 text-center text-gray-600">Reg</div>
                                    <div className="w-8 text-center text-gray-600">Pair</div>
                                </div>
                                <div className="relative h-full" style={{ width: `${FIGHT_DURATION * zoom}px` }}>
                                    {Array.from({ length: Math.ceil(FIGHT_DURATION / 30) + 1 }).map((_, i) => (
                                        <div key={i} className="absolute bottom-0 border-l border-gray-600 pl-1 pb-1 text-[10px] text-gray-500 font-mono select-none" style={{ left: `${i * 30 * zoom}px` }}>{formatTime(i * 30)}</div>
                                    ))}
                                </div>
                            </div>

                            {/* Phase Lines */}
                            {showPhases && (
                                <div className="absolute top-10 bottom-0 right-0 pointer-events-none z-0" style={{ left: `${LEFT_PANEL_WIDTH}px` }}>
                                    {bossMechanics.filter(m => m.type === 'phase' || m.type === 'window').map((mech, i) => (
                                        <div key={i} className="absolute top-0 bottom-0 border-l border-dashed z-0" style={{ left: `${mech.time * zoom}px`, borderColor: mech.color || 'rgba(255,255,255,0.1)' }} />
                                    ))}
                                </div>
                            )}

                            {/* Boss Timeline - Explicitly placed above players */}
                            {showBossRow && (
                                <div className="flex h-12 border-b border-gray-800/60 bg-[#151515] hover:bg-[#1a1a1a] transition-colors group relative sticky top-8 z-40">
                                    <div className="sticky left-0 bg-[#181818] border-r border-gray-800 shrink-0 flex items-center px-4 z-50 shadow-[4px_0_10px_rgba(0,0,0,0.5)]" style={{ width: `${LEFT_PANEL_WIDTH}px` }}>
                                        <div className="flex-1 font-bold text-gray-300">Boss Timeline</div>
                                    </div>
                                    <div className="relative h-full z-10" style={{ width: `${FIGHT_DURATION * zoom}px` }}>
                                        {bossMechanics.map((mech, i) => (
                                            mech.duration > 0 ? (
                                                /* Standard Boss Bar for duration mechanics */
                                                <div 
                                                    key={i} 
                                                    className="absolute top-1/2 -translate-y-1/2 h-6 rounded border border-white/10 flex items-center justify-center text-[10px] text-white/90 overflow-hidden shadow-sm" 
                                                    style={{ left: `${mech.time * zoom}px`, width: `${Math.max(mech.duration * zoom, 20)}px`, backgroundColor: mech.color }} 
                                                    title={`${mech.name} (${formatTime(mech.time)}) - ${mech.duration}s`}
                                                >
                                                    <span className="truncate px-1">{mech.name}</span>
                                                </div>
                                            ) : (
                                                /* Icon Box for instant mechanics */
                                                <div 
                                                    key={i} 
                                                    className="absolute top-1/2 -translate-y-1/2 h-6 w-6 rounded border border-white/20 flex items-center justify-center shadow-sm overflow-hidden" 
                                                    style={{ left: `${mech.time * zoom}px`, backgroundColor: '#333' }}
                                                    title={`${mech.name} (${formatTime(mech.time)})`}
                                                >
                                                    <RenderIcon spell={mech} />
                                                </div>
                                            )
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Player Rows */}
                            {rankData
                                .filter(row => {
                                    if (activeFilterSpecs.size === 0) return true;
                                    const comp = row.composition || [];
                                    // Check if all activeFilterSpecs are present in comp
                                    for (let spec of activeFilterSpecs) {
                                        if (!comp.includes(spec)) return false;
                                    }
                                    return true;
                                })
                                .map((row) => {
                                const visibleCasts = row.casts.filter(cast => selectedSpells.has(cast.spellId));
                                const { processedCasts, maxTracks } = isCollapsed
                                    ? { processedCasts: visibleCasts.map(c => ({ ...c, trackIndex: 0 })), maxTracks: 1 }
                                    : calculateCastTracks(visibleCasts);

                                // COMPACT MODE: 32px height per row
                                const rowHeight = 32;
                                const trackHeight = 30; // Height per sub-row when expanded
                                const totalHeight = isCollapsed ? rowHeight : Math.max(rowHeight, maxTracks * trackHeight);

                                return (
                                    <div key={row.id} className="flex border-b border-gray-800/40 hover:bg-[#1a1a1a] transition-colors group relative" style={{ height: `${totalHeight}px` }}>
                                        {/* Sticky Left Panel - Adjusted for Compact Height */}
                                        <div className="sticky left-0 bg-[#161616] group-hover:bg-[#1e1e1e] border-r border-gray-800 shrink-0 flex items-center px-4 z-40 transition-colors shadow-[4px_0_5px_rgba(0,0,0,0.2)]" style={{ width: `${LEFT_PANEL_WIDTH}px` }}>
                                            <div className="w-8 text-center mr-2 font-mono text-gray-500 text-xs">#{row.rank}</div>
                                            
                                            {/* MODIFIED: Use PlayerNameCell for Name/DPS toggle and pass report args */}
                                            <PlayerNameCell 
                                                name={row.name} 
                                                dps={row.dps} 
                                                reportId={row.reportId} 
                                                fightId={row.fightId} 
                                                region={row.region} 
                                            />
                                            
                                            <div className="w-8 text-center text-[10px] font-mono font-bold text-gray-500 bg-[#222] rounded px-1 py-0.5">{row.region}</div>
                                            
                                            {/* Partner Column - Only shows for Tank/Healer */}
                                            <div className="w-8 text-center flex justify-center items-center ml-1">
                                                {row.partner && <img src={row.partner} alt="P" className="w-5 h-5 object-contain" />}
                                            </div>
                                        </div>

                                        {/* Right Panel: Casts */}
                                        <div className="relative h-full z-10" style={{ width: `${FIGHT_DURATION * zoom}px` }}>
                                            {/* Grid Lines */}
                                            {Array.from({ length: Math.ceil(FIGHT_DURATION / 30) + 1 }).map((_, i) => (
                                                <div key={i} className="absolute top-0 bottom-0 border-l border-gray-800/20 pointer-events-none" style={{ left: `${i * 30 * zoom}px` }} />
                                            ))}
                                            
                                            {/* Deaths */}
                                            {showDeaths && row.deaths.map((deathTime, dIdx) => (
                                                <div key={dIdx} className="absolute top-1/2 -translate-y-1/2 text-gray-600 z-0" style={{ left: `${deathTime * zoom}px` }}><Skull size={14} /></div>
                                            ))}

                                            {/* Kill Time Marker Logic */}
                                            {row.killTimeSeconds && (
                                                <div 
                                                    className="absolute top-0 bottom-0 z-50 flex flex-col items-center pointer-events-none"
                                                    style={{ left: `${row.killTimeSeconds * zoom}px` }}
                                                >
                                                    {/* Vertical Line */}
                                                    <div className="h-full w-[2px] bg-red-500/60 shadow-[0_0_8px_rgba(239,68,68,0.6)]"></div>
                                                    
                                                    {/* Label - Positioned like a skill icon but text-only */}
                                                    <div className="absolute top-1/2 -translate-y-1/2 left-1 flex items-center z-50">
                                                        {/* Icon Box */}
                                                        <div
                                                            className="flex items-center justify-center rounded-sm bg-red-900/80 border border-red-500/50"
                                                            style={{
                                                                height: `${(isCollapsed ? totalHeight : trackHeight) * 0.85}px`,
                                                                width: `${(isCollapsed ? totalHeight : trackHeight) * 0.85}px`
                                                            }}
                                                        >
                                                            <Flag size={(isCollapsed ? totalHeight : trackHeight) * 0.85 * 0.6} className="text-white" />
                                                        </div>

                                                        {/* Text */}
                                                        <span 
                                                            className="ml-1 font-bold text-white drop-shadow-[0_1px_2px_rgba(0,0,0,0.8)] whitespace-nowrap"
                                                            style={{ fontSize: `${(isCollapsed ? totalHeight : trackHeight) * 0.85 * 0.7}px`, lineHeight: 1 }}
                                                        >
                                                            {row.killTime}
                                                        </span>
                                                    </div>
                                                </div>
                                            )}

                                            {processedCasts.map((cast, cIdx) => {
                                                const spell = spells[cast.spellId];
                                                if (!spell) return null;

                                                // --- KILL TIME CLIPPING LOGIC ---
                                                const timeUntilKill = row.killTimeSeconds ? (row.killTimeSeconds - cast.timestamp) : 99999;
                                                
                                                // If cast starts AFTER kill, skip it
                                                if (timeUntilKill <= 0) return null;

                                                // Vertical positioning
                                                const currentTrackHeight = isCollapsed ? totalHeight : trackHeight;
                                                const topPos = isCollapsed ? 0 : cast.trackIndex * trackHeight;

                                                // Dimensions - Adjusted for Compactness
                                                const iconHeight = currentTrackHeight * 0.85; 
                                                const rawDurationWidth = (cast.duration || 0) * zoom;
                                                const rawCdWidth = (spell.cd || 0) * zoom;
                                                
                                                // Max allowed width (distance to kill time)
                                                const maxVisibleWidth = timeUntilKill * zoom;

                                                // Clamp widths
                                                const durationWidth = Math.max(0, Math.min(rawDurationWidth, maxVisibleWidth));
                                                const cdWidth = Math.max(0, Math.min(rawCdWidth, maxVisibleWidth));

                                                // Color Assignment (Consistent per spell)
                                                const barColor = spellColorMap[cast.spellId] || '#ffffff';

                                                // Hex color to RGBA for lighter CD bar (using the assigned barColor)
                                                const hexToRgba = (hex, alpha) => {
                                                    // Handle simple hex codes
                                                    if (!hex) return `rgba(255,255,255,${alpha})`;
                                                    if (hex.startsWith('#')) {
                                                        let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
                                                        return `rgba(${r},${g},${b},${alpha})`;
                                                    }
                                                    return hex; // fallback if already rgb/rgba
                                                };

                                                return (
                                                    <div
                                                        key={cIdx}
                                                        className="absolute flex items-center group/icon select-none"
                                                        style={{
                                                            left: `${cast.timestamp * zoom}px`,
                                                            top: `${topPos}px`,
                                                            height: `${currentTrackHeight}px`,
                                                            zIndex: 10 + cIdx // Right skills cover left skills
                                                        }}
                                                    >
                                                        <div className="relative w-full h-full flex items-center">
                                                            
                                                            {/* 1. Cooldown Bar - CLAMPED */}
                                                            {showCooldown && spell.cd > 0 && cdWidth > 0 && (
                                                                <div 
                                                                    className="absolute top-1/2 -translate-y-1/2 h-1/3 rounded-r-sm z-0"
                                                                    style={{
                                                                        left: `${iconHeight/2}px`, 
                                                                        width: `${cdWidth}px`,
                                                                        backgroundColor: hexToRgba(barColor, 0.2)
                                                                    }}
                                                                />
                                                            )}

                                                            {/* 2. Duration Bar - CLAMPED */}
                                                            {showDuration && durationWidth > 0 && (
                                                                <div
                                                                    className="absolute left-0 z-10 rounded-sm shadow-sm"
                                                                    style={{
                                                                        width: `${durationWidth}px`,
                                                                        height: '90%',
                                                                        backgroundColor: barColor, // Use palette color
                                                                        opacity: 0.9
                                                                    }}
                                                                />
                                                            )}

                                                            {/* 3. Icon */}
                                                            <div
                                                                className="relative z-20 flex items-center justify-center overflow-hidden rounded-sm bg-black/50"
                                                                style={{
                                                                    height: `${iconHeight}px`,
                                                                    width: `${iconHeight}px`,
                                                                    minWidth: `${iconHeight}px`
                                                                }}
                                                            >
                                                                <RenderIcon spell={spell} className="opacity-100" />
                                                            </div>

                                                            {/* 4. Timestamp Text */}
                                                            <span 
                                                                className="ml-1 font-bold text-white drop-shadow-[0_1px_2px_rgba(0,0,0,0.8)] z-30 pointer-events-none"
                                                                style={{ fontSize: `${iconHeight * 0.7}px`, lineHeight: 1 }}
                                                            >
                                                                {formatTime(cast.timestamp)}
                                                            </span>

                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>